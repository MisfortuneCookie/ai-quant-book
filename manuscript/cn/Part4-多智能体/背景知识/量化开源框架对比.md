# 背景知识：量化开源框架对比

> 选择正确的框架可以节省数月开发时间。本文对比主流量化开源框架的优缺点和适用场景。

---

## 一、框架分类

| 类别 | 框架 | 主要用途 |
|-----|------|---------|
| **回测框架** | Backtrader, VectorBT, Zipline | 策略回测 |
| **研究框架** | QuantLib, PyAlgoTrade | 定价、研究 |
| **RL 框架** | FinRL, TensorTrade | 强化学习交易 |
| **全栈框架** | QuantConnect, Freqtrade | 回测+实盘 |

---

## 二、回测框架详解

### 2.1 VectorBT

**定位**：高性能向量化回测框架

**优点**：
- 极快的回测速度（向量化计算）
- 内置丰富的分析指标
- 支持参数优化
- 可视化功能强大
- 支持多资产组合

**缺点**：
- 学习曲线陡峭
- 不支持事件驱动
- 复杂策略表达困难
- 无内置实盘接口

**适用场景**：参数优化、快速回测、策略研究

**示例代码**：
```python
import vectorbt as vbt

# 获取数据
price = vbt.YFData.download('BTC-USD').get('Close')

# 双均线策略
fast_ma = vbt.MA.run(price, 10)
slow_ma = vbt.MA.run(price, 30)

entries = fast_ma.ma_crossed_above(slow_ma)
exits = fast_ma.ma_crossed_below(slow_ma)

# 回测
pf = vbt.Portfolio.from_signals(price, entries, exits)
print(pf.stats())
```

---

### 2.2 Backtrader

**定位**：事件驱动回测框架

**优点**：
- 事件驱动架构，逻辑清晰
- 支持多数据源、多时间框架
- 内置常用指标
- 社区活跃
- 支持实盘（需要 broker 适配）

**缺点**：
- 回测速度较慢
- 代码较冗长
- 维护不够活跃（原作者已较少更新）

**适用场景**：复杂策略、多资产、需要精细控制

**示例代码**：
```python
import backtrader as bt

class SmaCross(bt.Strategy):
    params = (('fast', 10), ('slow', 30),)

    def __init__(self):
        sma_fast = bt.ind.SMA(period=self.p.fast)
        sma_slow = bt.ind.SMA(period=self.p.slow)
        self.crossover = bt.ind.CrossOver(sma_fast, sma_slow)

    def next(self):
        if self.crossover > 0:
            self.buy()
        elif self.crossover < 0:
            self.sell()

cerebro = bt.Cerebro()
cerebro.addstrategy(SmaCross)
cerebro.run()
```

---

### 2.3 Zipline

**定位**：Quantopian 开源的回测引擎

**优点**：
- 机构级代码质量
- 支持 Pipeline API（因子研究）
- 事件驱动
- 完善的风险分析

**缺点**：
- Quantopian 已关闭，维护减少
- 安装依赖复杂
- 主要支持美股

**适用场景**：因子研究、美股策略

---

## 三、强化学习框架

### 3.1 FinRL

**定位**：金融强化学习一站式框架

**优点**：
- 集成多种 RL 算法（DQN, PPO, A2C, SAC 等）
- 内置金融环境
- 支持多种数据源
- 论文复现友好

**缺点**：
- 文档质量一般
- 代码结构复杂
- 实盘支持有限

**适用场景**：RL 策略研究、学术研究

**示例代码**：
```python
from finrl.agents.stablebaselines3.models import DRLAgent
from finrl.main import check_and_make_directories
from finrl.meta.env_stock_trading.env_stocktrading import StockTradingEnv

# 创建环境
env = StockTradingEnv(df=train_data, ...)

# 训练 Agent
agent = DRLAgent(env=env)
model = agent.get_model("ppo")
trained_model = agent.train_model(model, total_timesteps=100000)
```

---

### 3.2 TensorTrade

**定位**：可组合的交易环境框架

**优点**：
- 模块化设计
- 支持自定义组件
- 与 TensorFlow/PyTorch 集成

**缺点**：
- 维护不活跃
- 文档不完善
- 社区较小

**适用场景**：自定义 RL 环境研究

---

## 四、全栈框架

### 4.1 QuantConnect (LEAN)

**定位**：云端 + 本地的全栈量化平台

**优点**：
- 支持多资产（股票、期货、外汇、加密货币）
- 云端免费回测
- 本地部署开源（LEAN 引擎）
- 支持实盘（需要 broker）
- 多语言（Python, C#）

**缺点**：
- 本地部署复杂
- 云端有资源限制
- 学习成本较高

**适用场景**：全流程策略开发、多资产

---

### 4.2 Freqtrade

**定位**：加密货币交易机器人

**优点**：
- 专注加密货币
- 支持多交易所
- 内置回测 + 实盘
- Docker 部署简单
- 社区活跃

**缺点**：
- 仅支持加密货币
- 策略表达有限制

**适用场景**：加密货币自动交易

---

## 五、框架选择决策树

```
你的主要目标是什么？
│
├─ 快速验证策略想法
│   └─ VectorBT（最快）
│
├─ 复杂策略开发
│   └─ Backtrader（灵活）
│
├─ 因子研究
│   └─ Zipline + Alphalens
│
├─ 强化学习研究
│   └─ FinRL（最完整）
│
├─ 加密货币实盘
│   └─ Freqtrade（开箱即用）
│
└─ 多资产 + 实盘
    └─ QuantConnect LEAN
```

---

## 六、性能对比

| 框架 | 回测速度 | 内存占用 | 学习曲线 |
|-----|---------|---------|---------|
| VectorBT | 极快 | 高 | 陡峭 |
| Backtrader | 慢 | 中 | 中等 |
| Zipline | 中等 | 高 | 陡峭 |
| FinRL | 慢 | 高 | 陡峭 |
| Freqtrade | 中等 | 低 | 简单 |

---

## 七、实用建议

1. **初学者**：从 Backtrader 开始，理解事件驱动架构
2. **快速迭代**：用 VectorBT 做参数扫描
3. **RL 研究**：FinRL 提供完整起点
4. **生产系统**：考虑 QuantConnect LEAN 或自建
5. **加密货币**：Freqtrade 最省事

---

## 八、框架组合推荐

| 阶段 | 推荐组合 |
|-----|---------|
| 学习阶段 | Backtrader + yfinance |
| 研究阶段 | VectorBT + Jupyter |
| RL 研究 | FinRL + Stable-Baselines3 |
| 实盘阶段 | 自建系统 或 QuantConnect |

---

> **核心原则**：框架是工具，不是目的。选择能让你最快验证想法的框架，而不是功能最多的框架。
